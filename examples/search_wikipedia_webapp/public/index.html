<!doctype html>
<html>
<head>
<title>Wikipedia pages local search</title>
<style>
.result {
  margin: 0.5em 0;
}
.prevPage, .page, .nextPage {
  margin: 0 4px;
}
.prevPage, .page, .nextPage {
  text-decoration: none;
}
.prevPage:hover, a.page:hover, .nextPage:hover {
  text-decoration: underline;
}
</style>
</head>
<body>
<script src="/js/mithril.js"></script>
<script src="/js/observable.js"></script>
<script>
Result = function(data) {
  this.title = m.prop(data && data.title || "");
  this.text = m.prop(data && data.text || "");
};

Observable.on(['search'], function(data) {
  var url = "/search"
  var q = data.searchWord
  if (q !== "") {
    url += "?q=" + encodeURIComponent("_key:@" + q + " OR text:@" + q) +
      "&offset=" + data.offset + "&limit=" + data.limit
  }
  return m.request({method: "GET", url: url})
  .then(function(data) {
    Observable.trigger('searchDone', data)
  })
})

var SearchWidget = (function () {
  var vm = {
    display: m.prop('none'),
    searchWord: m.prop(''),
    currentPage: m.prop(1),
    itemsPerPage: m.prop(10),
    results: m.prop([]),
    numItems: m.prop(0),
    numPages: function() {
      return Math.floor((vm.numItems() - 1) / vm.itemsPerPage()) + 1
    }
  }

  Observable.on(['searchDone'], function(data) {
    vm.display('block')
    vm.numItems(data.matchedCount)
    vm.results(data.results.map(function(result) {
      return new Result(result)
    }))
  })

  var queryParams = function() {
    var params = {}
    var a = window.location.search.substr(1).split('&')
    for (var i = 0, len = a.length; i < len; i++) {
      var b = a[i].split('=', 2)
      if (b[0] !== '') {
        params[b[0]] = decodeURIComponent(b[1])
      }
    }
    return params
  }

  return {
    controller: function() {
      this.search = function() {
        vm.currentPage(1)
        m.route('q=' + encodeURIComponent(vm.searchWord()) + '&start=' + 0)
        Observable.trigger('search', {
          searchWord: vm.searchWord(),
          offset: 0,
          limit: vm.itemsPerPage()
        })
        return false
      }
      this.jumpToPage = function(page) {
        var offset = (page - 1) * vm.itemsPerPage()
        vm.currentPage(page)
        m.route('q=' + encodeURIComponent(vm.searchWord()) + '&start=' + offset)
        Observable.trigger('search', {
          searchWord: vm.searchWord(),
          offset: offset,
          limit: vm.itemsPerPage()
        })
        return false
      }

      var params = queryParams()
      if (params.q) {
        vm.searchWord(params.q)
        this.jumpToPage(Math.floor(params.start / vm.itemsPerPage()) + 1)
      }
    },
    view: function(ctrl) {
      return [
        m.component(SearchForm, {
          searchWord: vm.searchWord,
          onsubmit: ctrl.search
        }),
        m.component(SearchResultWidget, {
          display: vm.display,
          numItems: vm.numItems,
          results: vm.results
        }),
        m.component(PaginationWidget, {
          display: vm.display,
          currentPage: vm.currentPage,
          numPages: vm.numPages,
          onclick: ctrl.jumpToPage
        })
      ]
    }
  }
})()

var SearchForm = (function() {
  return {
    controller: function() {},
    view: function(ctrl, args) {
      return m('form.search[method=get]',
          {onsubmit: args.onsubmit.bind(this)},
      [
        m('input', {
          onchange: m.withAttr('value', args.searchWord),
          value: args.searchWord()
        }),
        m('input[type=submit][value=Search]')
      ])
    }
  }
})()

var SearchResultWidget = (function() {
  return {
    controller: function() {},
    view: function(ctrl, args) {
      var wikipediaLink = function(title) {
        return "https://ja.wikipedia.org/wiki/" + encodeURIComponent(title())
      }
      return m('.results[style="display:' + args.display() + '"]', [
        m('.matchedCount', '検索結果 約' + args.numItems() + '件'), 
        args.results().map(function(result, index) {
          return m(".result", [
            m(".title", [
              m("a[href=" + wikipediaLink(result.title) + "][target=_blank]",
                result.title())
            ]),
            m(".text", result.text())
          ])
        })
      ])
    }
  }
})()

var PaginationWidget = (function(){
  var vm = {
    maxViewablePages: m.prop(9) // must be an odd number
  }

  return {
    controller: function() {},
    view: function(ctrl, args) {
      var numPages = args.numPages()
      var currentPage = args.currentPage()
      var hasPrevPage = currentPage > 1
      var hasNextPage = currentPage < numPages
      var viewablePages = function() {
        var maxViewablePages = vm.maxViewablePages()
        var viewablePageCount = Math.min(numPages, maxViewablePages)
        var startPage = currentPage - Math.floor(viewablePageCount / 2)
        var endPage = startPage + viewablePageCount
        if (startPage < 1) {
          startPage = 1
          endPage = viewablePageCount
        } else if (endPage > numPages) {
          startPage = numPages - viewablePageCount
          endPage = numPages
        }
        var pages = []

        for (var i = startPage; i <= endPage; i++) {
          pages.push(i)
        }
        return pages
      }
      return m('.pagination[style="display:' + args.display() + '"]', [
        hasPrevPage ?
          m('a.prevPage[href=#]',
            {onclick: args.onclick.bind(this, currentPage - 1)}, '前へ') :
            undefined,
        viewablePages().map(function(page) {
          return page === currentPage ? m('span.page', page) :
            m('a.page[href=#]',
              {onclick: args.onclick.bind(this, page)}, page)
        }),
        hasNextPage ?
          m('a.nextPage[href=#]',
            {onclick: args.onclick.bind(this, currentPage + 1)}, '次へ') :
            undefined
      ])
    }
  }
})()

m.mount(document.body, SearchWidget)
</script>
<body>
</html>
